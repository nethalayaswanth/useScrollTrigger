{"version":3,"file":"index.modern.js","sources":["../src/utils.ts","../src/trigger.ts","../src/hooks/useStable.ts","../src/hooks/useIsomorphicLayoutEffect.ts","../src/hooks/useResolvedElement.ts","../src/index.tsx","../src/hooks/useResizeObserver.ts"],"sourcesContent":["import { MutableRefObject, LegacyRef } from \"react\";\r\n\r\nexport const clamp = (value: number, min: number, max: number) =>\r\n  Math.max(min, Math.min(value, max));\r\n\r\nexport type Ref<T> = MutableRefObject<T> | LegacyRef<T> | undefined;\r\nexport function mergeRefs<T = any>(...refs: Ref<T>[]): React.RefCallback<T> {\r\n  return (value) => {\r\n    refs.forEach((ref) => {\r\n      if (typeof ref === \"function\") {\r\n        ref(value);\r\n      } else if (ref != null) {\r\n        (ref as React.MutableRefObject<T | null>).current = value;\r\n      }\r\n    });\r\n  };\r\n}\r\n\r\nexport function extractSize(\r\n  entry: ResizeObserverEntry,\r\n  boxProp: \"borderBoxSize\" | \"contentBoxSize\" | \"devicePixelContentBoxSize\",\r\n  sizeType: keyof ResizeObserverSize\r\n): number | undefined {\r\n  if (!entry[boxProp]) {\r\n    if (boxProp === \"contentBoxSize\") {\r\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  return entry[boxProp][0]\r\n    ? entry[boxProp][0][sizeType]\r\n    : // @ts-ignore\r\n      entry[boxProp][sizeType];\r\n}\r\n","import { clamp } from \"./utils\";\r\n\r\nconst ROOTMARGINEXT = 20;\r\n\r\nexport interface IntersectionOptions extends IntersectionObserverInit {}\r\n\r\nexport interface EventCallbackProps {\r\n  node: HTMLElement;\r\n  entry: IntersectionObserverEntry;\r\n  scrollingUp: boolean;\r\n  progress: number;\r\n}\r\n\r\ntype Observer = IntersectionObserver | null;\r\n\r\n\r\nexport default class ScrollTrigger {\r\n  private nodes = new Map<HTMLElement, any>();\r\n  private visibleNodes = new Map<HTMLElement, IntersectionObserverEntry>();\r\n  private animatingNodes = new Set<HTMLElement>();\r\n  private observer: IntersectionObserver | null = null;\r\n  private scroller: Element | Document | null | undefined = null;\r\n  private direction: string | null = null;\r\n  private mounted = false;\r\n  private prevYPosition = 0;\r\n  private scroll = true;\r\n\r\n  private static readonly ROOTMARGINEXT = 0; // Replace this with the actual value\r\n\r\n  private setScrollDirection(scrollTop: number) {\r\n    if (scrollTop < this.prevYPosition) {\r\n      this.direction = \"down\";\r\n    } else {\r\n      this.direction = \"up\";\r\n    }\r\n    this.prevYPosition = scrollTop;\r\n  }\r\n\r\n  private handleIntersecting(entry: IntersectionObserverEntry) {\r\n    let target = entry.target as HTMLElement;\r\n    if (entry.isIntersecting) {\r\n      this.visibleNodes.set(target, entry);\r\n      target.classList.add(\"trigger\");\r\n    } else {\r\n      if (!this.direction) return;\r\n\r\n      const scrollingUp = this.direction === \"up\";\r\n\r\n      target.classList.remove(\"trigger\");\r\n      target.style.setProperty(\"--trigger\", scrollingUp ? \" 1\" : \" 0\");\r\n      target.style.setProperty(\r\n        \"--trigger-px\",\r\n        scrollingUp ? target.dataset.end ?? \"0\" : \"0\"\r\n      );\r\n    }\r\n  }\r\n\r\n  private updateEntries(entries: IntersectionObserverEntry[]) {\r\n    this.visibleNodes = new Map();\r\n    entries.forEach((entry) => {\r\n      this.handleIntersecting(entry);\r\n    });\r\n  }\r\n\r\n  private caluclatePosition(entry: IntersectionObserverEntry) {\r\n     if (!entry) return [0, 0];\r\n\r\n      var { top: elTop, height: elHeight } = entry.boundingClientRect;\r\n      if (!entry.rootBounds) return [0, 0];\r\n      var { height: rootHeight } = entry.rootBounds;\r\n      var rootVisibleHeight = rootHeight - 2 * ROOTMARGINEXT;\r\n      var start = 0;\r\n      var end = rootVisibleHeight + elHeight;\r\n\r\n      let target = entry.target as HTMLElement;\r\n      if (target.dataset.start) {\r\n        start = parseInt(target.dataset.start, 10);\r\n      }\r\n      if (target.dataset.end) {\r\n        end = parseInt(target.dataset.end, 10);\r\n      }\r\n      var track = end - start;\r\n      var posTop = rootVisibleHeight - elTop - start;\r\n      var pos = posTop / track;\r\n\r\n      return [clamp(pos, 0, 1), clamp(posTop, 0, track)];\r\n  }\r\n\r\n  private update() {\r\n    this.visibleNodes.forEach((entry, node) => {\r\n      var style = node.style;\r\n      var id = node.id;\r\n\r\n      const [progress, pixels] = this.caluclatePosition(entry);\r\n      const scrollingUp = this.direction === \"up\";\r\n      const { onStart, onProgress, onEnd } = this.nodes.get(node);\r\n\r\n      if (progress > 0 && progress < 1) {\r\n        if (!this.animatingNodes.has(node)) {\r\n          this.animatingNodes.add(node);\r\n\r\n          if (scrollingUp) {\r\n            onStart({ node, entry, scrollingUp, progress });\r\n          }\r\n        }\r\n\r\n        onProgress({ node, entry, scrollingUp, progress });\r\n      } else if (progress === 0 || progress === 1) {\r\n        if (this.animatingNodes.has(node)) {\r\n          if (progress === 1) {\r\n            onEnd({ node, entry, scrollingUp, progress });\r\n          }\r\n          this.animatingNodes.delete(node);\r\n        }\r\n      }\r\n\r\n      style.setProperty(\"--trigger\", `${progress}`);\r\n      style.setProperty(\"--trigger-px\", `${pixels}`);\r\n    });\r\n  }\r\n\r\n  public initObserver({ root, ...observerOptions }: IntersectionOptions) {\r\n    this.scroller = root;\r\n    this.observer = new IntersectionObserver(\r\n      (entries, observer) => {\r\n        this.updateEntries(entries);\r\n        this.update();\r\n      },\r\n      { root, rootMargin: `${ScrollTrigger.ROOTMARGINEXT}px 0px`, ...observerOptions }\r\n    );\r\n  }\r\n\r\n  public init(observerOptions: IntersectionOptions) {\r\n    this.initObserver(observerOptions);\r\n    this.observeAll();\r\n    this.onScroll();\r\n\r\n    return this;\r\n  }\r\n\r\n  public add({ node, ...props }: { node: HTMLElement }) {\r\n    this.nodes.set(node, props);\r\n    node.style.setProperty(\"--trigger\", \"0\");\r\n    node.style.setProperty(\"--trigger-px\", \"0\");\r\n    this.observe(node);\r\n  }\r\n\r\n  public observe(element: HTMLElement) {\r\n    if (this.observer) this.observer.observe(element);\r\n  }\r\n\r\n  public unobserve(element: HTMLElement) {\r\n    if (this.observer) this.observer.unobserve(element);\r\n  }\r\n\r\n  public destroy() {\r\n    if (this.observer) this.observer.disconnect();\r\n  }\r\n\r\n  public observeAll() {\r\n    this.nodes.forEach((value, node) => {\r\n      this.observe(node);\r\n    });\r\n  }\r\n\r\n  public onScroll(e?: Event) {\r\n    if (e && this.mounted) {\r\n      if (!(e.target instanceof HTMLElement || e.target instanceof Window))\r\n        return;\r\n\r\n      const scrollTop =\r\n        e.target instanceof HTMLElement\r\n          ? e.target.scrollTop\r\n          : e.target instanceof Document\r\n          ? e.target.documentElement.scrollTop\r\n          : e.target instanceof Window\r\n          ? e.target.scrollX\r\n          : 0;\r\n      this.mounted = true;\r\n\r\n      this.setScrollDirection(scrollTop);\r\n    }\r\n\r\n    if (this.visibleNodes && this.visibleNodes.size !== 0) {\r\n      this.visibleNodes.forEach((value, element) => {\r\n        this.unobserve(element);\r\n        this.observe(element);\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n","import * as React from \"react\";\r\n\r\nconst useLatest = <T extends any>(current: T) => {\r\n  const storedValue = React.useRef(current);\r\n  React.useEffect(() => {\r\n    storedValue.current = current;\r\n  });\r\n  return storedValue;\r\n};\r\n\r\nexport default useLatest;\r\n","import { useEffect, useLayoutEffect } from \"react\";\r\n\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\r\n\r\nexport default useIsomorphicLayoutEffect;\r\n","import { RefCallback, RefObject, useCallback, useEffect, useRef } from \"react\";\r\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\r\n\r\ntype SubscriberCleanupFunction = () => void;\r\ntype SubscriberResponse = SubscriberCleanupFunction | void;\r\n\r\nexport default function useResolvedElement<T extends Element>(\r\n  subscriber: (element: T) => SubscriberResponse,\r\n  refOrElement?: T | RefObject<T> | null\r\n): RefCallback<T> {\r\n  const lastReportRef = useRef<{\r\n    element: T | null;\r\n    subscriber: typeof subscriber;\r\n    cleanup?: SubscriberResponse;\r\n  } | null>(null);\r\n  const refOrElementRef = useRef<typeof refOrElement>(null);\r\n  refOrElementRef.current = refOrElement;\r\n  const cbElementRef = useRef<T | null>(null);\r\n\r\n  const evaluateSubscription = useCallback(() => {\r\n    const cbElement = cbElementRef.current;\r\n    const refOrElement = refOrElementRef.current;\r\n\r\n    const element = cbElement\r\n      ? cbElement\r\n      : refOrElement\r\n      ? refOrElement instanceof Element\r\n        ? refOrElement\r\n        : refOrElement.current\r\n      : null;\r\n\r\n    if (\r\n      lastReportRef.current &&\r\n      lastReportRef.current.element === element &&\r\n      lastReportRef.current.subscriber === subscriber\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    if (lastReportRef.current && lastReportRef.current.cleanup) {\r\n      lastReportRef.current.cleanup();\r\n    }\r\n    lastReportRef.current = {\r\n      element,\r\n      subscriber,\r\n\r\n      cleanup: element ? subscriber(element) : undefined\r\n    };\r\n  }, [subscriber]);\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    evaluateSubscription();\r\n  });\r\n\r\n  useIsomorphicLayoutEffect(() => {\r\n    return () => {\r\n      if (lastReportRef.current && lastReportRef.current.cleanup) {\r\n        lastReportRef.current.cleanup();\r\n        lastReportRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return useCallback(\r\n    (element) => {\r\n      cbElementRef.current = element;\r\n      evaluateSubscription();\r\n    },\r\n    [evaluateSubscription]\r\n  );\r\n}\r\n/*  The MIT License (MIT)\r\n Copyright 2018 Viktor Hubert <rpgmorpheus@gmail.com> */\r\n","import {\n  useCallback,\n  useLayoutEffect,\n  useState,\n  RefObject,\n  useMemo\n} from \"react\";\nimport { mergeRefs } from \"./utils\";\nimport ScrollTrigger, { EventCallbackProps } from \"./trigger\";\nimport useStable from \"./hooks/useStable\";\nimport useResolvedElement from \"./hooks/useResolvedElement\";\nimport useResizeObserver, { ResizeHandler } from \"./hooks/useResizeObserver\";\n\ntype Register = {\n  name: string;\n  start?: string;\n  end?: string;\n  ref?: RefObject<HTMLElement>;\n  refKey?: string;\n  style?: CSSStyleSheet;\n  onProgress?: (arg: EventCallbackProps) => void;\n  onEntering?: (arg: EventCallbackProps) => void;\n  onEntered?: (arg: EventCallbackProps) => void;\n  onLeaving?: (arg: EventCallbackProps) => void;\n  onLeft?: (arg: EventCallbackProps) => void;\n  onEnteredBack?: (arg: EventCallbackProps) => void;\n  onLeaveBack?: (arg: EventCallbackProps) => void;\n  onStart?: (arg: EventCallbackProps) => void;\n  onEnd?: (arg: EventCallbackProps) => void;\n};\n\nexport const useScrollTrigger = <T extends HTMLElement>({\n  root,\n  onScroll\n}: {\n  root?: T | RefObject<T> | null;\n  onScroll?: (e: Event) => void;\n}) => {\n  const getScroller = useCallback(() => {\n    const scroller = !root\n      ? document.documentElement\n      : typeof root === \"string\"\n      ? document.getElementById(root)\n      : root instanceof HTMLElement\n      ? root\n      : root.current;\n    return scroller;\n  }, [root]);\n\n  const [trigger] = useState(() => new ScrollTrigger());\n\n  const onScrollRef = useStable(onScroll);\n\n  useLayoutEffect(() => {\n    trigger.init({ root: getScroller() });\n  }, [getScroller, trigger]);\n\n  const containerRef = useResolvedElement<HTMLElement>((element) => {\n    const handleScroll = (e: Event) => {\n      trigger.onScroll(e);\n      onScrollRef.current?.(e);\n    };\n\n    element.addEventListener(\"scroll\", handleScroll, { passive: true });\n    return () => {\n      trigger.destroy();\n      element.removeEventListener(\"scroll\", handleScroll, ({\n        passive: true\n      } as unknown) as EventListenerOptions);\n    };\n  }, getScroller());\n\n  const { ref: resizeRef } = useResizeObserver({\n    ref: getScroller(),\n    onResize: useCallback(() => {\n      trigger.observeAll();\n    }, [trigger]) as ResizeHandler\n  });\n\n  const registerCb = (props: Register & { node: HTMLElement }) => {\n    const { node, start, end } = props;\n    node.dataset.start = start;\n    node.dataset.end = end;\n    trigger.add(props);\n  };\n\n  function register({ name, ref, style, ...rest }: Register) {\n    return {\n      id: `${name}`,\n      ref: mergeRefs((node) => {\n        if (!node) return;\n        registerCb({\n          node,\n          name,\n          ...rest\n        });\n      }, ref),\n      style: {\n        ...style\n      }\n    };\n  }\n\n  const scrollerRef = useMemo(() => mergeRefs(containerRef, resizeRef), [\n    containerRef,\n    resizeRef\n  ]);\n  return { register, scrollerRef };\n};\n\nexport default useScrollTrigger;\n","import {\r\n  useEffect,\r\n  useState,\r\n  useRef,\r\n  useMemo,\r\n  RefObject,\r\n  RefCallback,\r\n  useCallback\r\n} from \"react\";\r\n\r\nimport useResolvedElement from \"./useResolvedElement\";\r\nimport { extractSize } from \"../utils\";\r\n\r\nexport type ObservedSize = {\r\n  width: number | undefined;\r\n  height: number | undefined;\r\n};\r\n\r\nexport type ResizeHandler = (size: ObservedSize) => void;\r\n\r\ntype HookResponse<T extends Element> = {\r\n  ref: RefCallback<T>;\r\n} & ObservedSize;\r\n\r\nexport type ResizeObserverBoxOptions =\r\n  | \"border-box\"\r\n  | \"content-box\"\r\n  | \"device-pixel-content-box\";\r\n\r\ndeclare global {\r\n  interface ResizeObserverEntry {\r\n    readonly devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>;\r\n  }\r\n}\r\n\r\nexport type RoundingFunction = (n: number) => number;\r\n\r\nfunction useResizeObserver<T extends Element>(\r\n  opts: {\r\n    ref?: RefObject<T> | T | null | undefined;\r\n    onResize?: ResizeHandler;\r\n    box?: ResizeObserverBoxOptions;\r\n    round?: RoundingFunction;\r\n  } = {}\r\n): HookResponse<T> {\r\n  const onResize = opts.onResize;\r\n  const onResizeRef = useRef<ResizeHandler | undefined>(undefined);\r\n  onResizeRef.current = onResize;\r\n  const round = opts.round || Math.round;\r\n\r\n  const resizeObserverRef = useRef<{\r\n    box?: ResizeObserverBoxOptions;\r\n    round?: RoundingFunction;\r\n    instance: ResizeObserver;\r\n  }>();\r\n\r\n  const [size, setSize] = useState<{\r\n    width?: number;\r\n    height?: number;\r\n  }>({\r\n    width: undefined,\r\n    height: undefined\r\n  });\r\n\r\n  const didUnmount = useRef(false);\r\n  useEffect(() => {\r\n    didUnmount.current = false;\r\n\r\n    return () => {\r\n      didUnmount.current = true;\r\n    };\r\n  }, []);\r\n\r\n  const previous: {\r\n    current: {\r\n      width?: number;\r\n      height?: number;\r\n    };\r\n  } = useRef({\r\n    width: undefined,\r\n    height: undefined\r\n  });\r\n\r\n  const refCallback = useResolvedElement<T>(\r\n    useCallback(\r\n      (element) => {\r\n        if (\r\n          !resizeObserverRef.current ||\r\n          resizeObserverRef.current.box !== opts.box ||\r\n          resizeObserverRef.current.round !== round\r\n        ) {\r\n          resizeObserverRef.current = {\r\n            box: opts.box,\r\n            round,\r\n            instance: new ResizeObserver((entries) => {\r\n              const entry = entries[0];\r\n\r\n              const boxProp =\r\n                opts.box === \"border-box\"\r\n                  ? \"borderBoxSize\"\r\n                  : opts.box === \"device-pixel-content-box\"\r\n                  ? \"devicePixelContentBoxSize\"\r\n                  : \"contentBoxSize\";\r\n\r\n              const reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\r\n              const reportedHeight = extractSize(entry, boxProp, \"blockSize\");\r\n\r\n              const newWidth = reportedWidth ? round(reportedWidth) : undefined;\r\n              const newHeight = reportedHeight\r\n                ? round(reportedHeight)\r\n                : undefined;\r\n\r\n              if (\r\n                previous.current.width !== newWidth ||\r\n                previous.current.height !== newHeight\r\n              ) {\r\n                const newSize = { width: newWidth, height: newHeight };\r\n                previous.current.width = newWidth;\r\n                previous.current.height = newHeight;\r\n                if (onResizeRef.current) {\r\n                  onResizeRef.current(newSize);\r\n                } else {\r\n                  if (!didUnmount.current) {\r\n                    setSize(newSize);\r\n                  }\r\n                }\r\n              }\r\n            })\r\n          };\r\n        }\r\n\r\n        resizeObserverRef.current.instance.observe(element, { box: opts.box });\r\n\r\n        return () => {\r\n          if (resizeObserverRef.current) {\r\n            resizeObserverRef.current.instance.unobserve(element);\r\n          }\r\n        };\r\n      },\r\n      [opts.box, round]\r\n    ),\r\n    opts.ref\r\n  );\r\n\r\n  return useMemo(\r\n    () => ({\r\n      ref: refCallback,\r\n      width: size.width,\r\n      height: size.height\r\n    }),\r\n    [refCallback, size.width, size.height]\r\n  );\r\n}\r\n\r\nexport default useResizeObserver;\r\n\r\n/*  The MIT License (MIT)\r\n Copyright 2018 Viktor Hubert <rpgmorpheus@gmail.com> */\r\n"],"names":["clamp","value","min","max","Math","mergeRefs","refs","forEach","ref","current","extractSize","entry","boxProp","sizeType","contentRect","ScrollTrigger","constructor","this","nodes","Map","visibleNodes","animatingNodes","Set","observer","scroller","direction","mounted","prevYPosition","scroll","setScrollDirection","scrollTop","handleIntersecting","target","isIntersecting","set","classList","add","_target$dataset$end","scrollingUp","remove","style","setProperty","dataset","end","updateEntries","entries","caluclatePosition","top","elTop","height","elHeight","boundingClientRect","rootBounds","rootHeight","rootVisibleHeight","start","parseInt","track","posTop","update","node","progress","pixels","onStart","onProgress","onEnd","get","has","delete","initObserver","_ref","root","observerOptions","_objectWithoutPropertiesLoose","_excluded","IntersectionObserver","_extends","rootMargin","ROOTMARGINEXT","init","observeAll","onScroll","_ref2","props","_excluded2","observe","element","unobserve","destroy","disconnect","e","HTMLElement","Window","Document","documentElement","scrollX","size","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","useResolvedElement","subscriber","refOrElement","lastReportRef","useRef","refOrElementRef","cbElementRef","evaluateSubscription","useCallback","Element","cleanup","undefined","useScrollTrigger","getScroller","document","getElementById","trigger","useState","onScrollRef","storedValue","React","useStable","containerRef","handleScroll","addEventListener","passive","removeEventListener","resizeRef","opts","onResize","onResizeRef","round","resizeObserverRef","setSize","width","didUnmount","previous","refCallback","box","instance","ResizeObserver","reportedWidth","reportedHeight","newWidth","newHeight","newSize","useMemo","useResizeObserver","register","name","rest","id","registerCb","scrollerRef"],"mappings":"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"}